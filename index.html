<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>Chess with Dobby by Wisdomtech</title>
  <style>
    body {
       background: radial-gradient(circle at center, chocolate 0%, black 100%);
      color: #eee;
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      max-width: 500px;
      width: 100vw;
      
      margin: 0;
      padding: 10px;
    }
    h1 { margin: 10px; color: #fff; }
    #boardContainer {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 20px 0;
    }
      a {
          text-decoration: none;
          color: darkblue;
      }
    #board {
      display: grid;
      grid-template-columns: repeat(8, 70px);
      grid-template-rows: repeat(8, 70px);
      border: 4px solid #444;
      position: relative;
    }
    .board-label {
      font-size: 16px;
      font-weight: bold;
      padding: 8px 16px;
      border-radius: 20px;
      margin: 10px 0;
      text-align: center;
      min-width: 100px;
    }
    .player-side {
      background: rgba(74, 158, 255, 0.2);
      border: 2px solid #4a9eff;
      color: #4a9eff;
    }
    .dobby-side {
      background: rgba(255, 74, 74, 0.2);
      border: 2px solid #ff4a4a;
      color: #ff4a4a;
    }
    .square {
      width: 70px;
      height: 70px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      position: relative;
      user-select: none;
      padding: 2px;
    }
    .piece-symbol {
      font-size: 32px;
      line-height: 1;
      margin-bottom: 1px;
    }
    .piece-owner {
      font-size: 8px;
      font-weight: bold;
      text-transform: uppercase;
      text-shadow: 1px 1px 1px rgba(0,0,0,0.8);
      line-height: 1;
      text-align: center;
    }
    .player-piece { color: #4a9eff; }
    .dobby-piece { color: #ff4a4a; }
    .light { background: #f0d9b5; }
    .dark { background: #b58863; }
    .highlight { 
      background: #ffff99 !important; 
      box-shadow: inset 0 0 15px #ff6600;
      border: 2px solid #ff6600;
    }
    .possible-move {
      background: rgba(0, 255, 0, 0.4) !important;
      position: relative;
    }
    .possible-move::after {
      content: '‚Ä¢';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #00ff00;
      font-size: 20px;
      font-weight: bold;
      z-index: 5;
    }
    .check-warning {
      background: rgba(255, 0, 0, 0.6) !important;
      animation: pulse 1.5s infinite;
      border: 3px solid #ff0000 !important;
    }
    .checkmate-king {
      background: rgba(255, 0, 0, 0.8) !important;
      animation: flash 0.5s infinite;
      border: 4px solid #ff0000 !important;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; box-shadow: 0 0 20px #ff0000; }
      50% { opacity: 0.7; box-shadow: 0 0 40px #ff0000; }
    }
    @keyframes flash {
      0%, 50%, 100% { background: rgba(255, 0, 0, 0.8); }
      25%, 75% { background: rgba(255, 255, 0, 0.8); }
    }
    .animated-piece {
      position: absolute;
      width: 70px;
      height: 70px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      z-index: 10;
      transition: all 0.6s ease-in-out;
      background: rgba(255, 255, 0, 0.3);
      border-radius: 50%;
      padding: 2px;
      box-shadow: 0 0 15px rgba(255, 255, 0, 0.8);
    }
    #gameInfo {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      width: 100%;
      max-width: 600px;
    }
    #status {
      font-size: 18px;
      font-weight: bold;
      text-align: center;
      min-height: 25px;
      background: #333;
      padding: 10px;
      border-radius: 5px;
      width: 100%;
    }
    .status-check {
      background: #cc3333 !important;
      color: #fff;
      animation: statusPulse 1s infinite;
    }
    .status-checkmate {
      background: #ff0000 !important;
      color: #fff;
      font-size: 20px;
      animation: statusFlash 0.8s infinite;
    }
    @keyframes statusPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.02); }
    }
    @keyframes statusFlash {
      0%, 100% { transform: scale(1); background: #ff0000; }
      50% { transform: scale(1.05); background: #ffaa00; }
    }
    #captured {
      font-size: 16px;
      background: #444;
      padding: 8px;
      border-radius: 5px;
      width: 100%;
      text-align: center;
    }
    #comments {
      background: #2a2a2a;
      border: 1px solid #555;
      border-radius: 8px;
      padding: 15px;
      max-height: 200px;
      overflow-y: auto;
      width: 100%;
      font-family: monospace;
    }
    .comment {
      margin: 5px 0;
      padding: 5px;
      border-radius: 3px;
    }
    .user-comment {
      background: #1a4a1a;
      border-left: 3px solid #4a9;
    }
    .dobby-comment {
      background: #4a1a1a;
      border-left: 3px solid #a49;
    }
    .system-comment {
      background: #1a1a4a;
      border-left: 3px solid #49a;
      font-style: italic;
    }
    .disabled {
      pointer-events: none;
      opacity: 0.8;
    }
    .game-over-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    .game-over-message {
      background: #333;
      padding: 30px;
      border-radius: 15px;
      text-align: center;
      border: 3px solid #666;
      max-width: 400px;
    }
    .victory { border-color: #4a9eff; background: #1a3a5a; }
    .defeat { border-color: #ff4a4a; background: #5a1a1a; }
  </style>
</head>
<body>
  <h1> Chess‚ôüÔ∏è vs Dobby(Powered by Dobby)</h1>
    
  
  <div id="boardContainer">
    <div class="board-label dobby-side">üè†<img src="img/redsentient.png" width="50px" height="50px"> DOBBY'S SIDE</div>
    <div id="board"></div>
    <div class="board-label player-side">üë§ <img src="img/sentient.png" width="50px" height="50px">PLAYER'S SIDE</div>
  </div>
  
  <div id="gameInfo">
    <div id="status">Your move (player) - Click a piece to select it</div>
    <div id="captured">
      <strong>You captured:</strong> <span id="whiteScore">0</span> points | 
      <strong>Dobby captured:</strong> <span id="blackScore">0</span> points
    </div>
    <div id="comments">
      <div class="comment system-comment"><strong>[System]:</strong> Game started! You are White, Dobby is Black. Protect your King!</div>
    </div>
  </div>

<script>
const FIREWORKS_API_KEY = "fw_3ZYt5vRJztdY1fXajRko5YCt";

// Chess piece Unicode symbols
const pieces = {
  // White pieces (you)
  'K': '‚ôî', 'Q': '‚ôï', 'R': '‚ôñ', 'B': '‚ôó', 'N': '‚ôò', 'P': '‚ôô',
  // Black pieces (Dobby)
  'k': '‚ôö', 'q': '‚ôõ', 'r': '‚ôú', 'b': '‚ôù', 'n': '‚ôû', 'p': '‚ôü'
};

// Piece values for scoring
const pieceValues = {
  'p': 1, 'n': 3, 'b': 3, 'r': 5, 'q': 9, 'k': 0,
  'P': 1, 'N': 3, 'B': 3, 'R': 5, 'Q': 9, 'K': 0
};

// Initial chess board setup
let board = [
  ['r','n','b','q','k','b','n','r'],
  ['p','p','p','p','p','p','p','p'],
  ['','','','','','','',''],
  ['','','','','','','',''],
  ['','','','','','','',''],
  ['','','','','','','',''],
  ['P','P','P','P','P','P','P','P'],
  ['R','N','B','Q','K','B','N','R']
];

let selectedSquare = null;
let currentPlayer = 'white';
let isAnimating = false;
let whiteScore = 0;
let blackScore = 0;
let gameHistory = [];
let possibleMoves = [];
let gameOver = false;
let whiteKingPos = {row: 7, col: 4};
let blackKingPos = {row: 0, col: 4};
let isWhiteInCheck = false;
let isBlackInCheck = false;

const boardElement = document.getElementById('board');
const statusElement = document.getElementById('status');
const whiteScoreElement = document.getElementById('whiteScore');
const blackScoreElement = document.getElementById('blackScore');
const commentsElement = document.getElementById('comments');

// Initialize the game
function initGame() {
  renderBoard();
  addComment('system', 'Welcome to play with dobby(chess)! Protect your King and capture his!');
}

// Check if piece is white
function isWhitePiece(piece) {
  return piece && piece === piece.toUpperCase();
}

// Find king position
function findKing(isWhite) {
  const kingSymbol = isWhite ? 'K' : 'k';
  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      if (board[row][col] === kingSymbol) {
        return {row, col};
      }
    }
  }
  return null;
}

// Check if a square is under attack by the enemy
function isSquareUnderAttack(targetRow, targetCol, byWhite) {
  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      const piece = board[row][col];
      if (piece && isWhitePiece(piece) === byWhite) {
        if (canPieceAttack(row, col, targetRow, targetCol)) {
          return true;
        }
      }
    }
  }
  return false;
}

// Check if a piece can attack a square (for check detection)
function canPieceAttack(fromRow, fromCol, toRow, toCol) {
  const piece = board[fromRow][fromCol];
  if (!piece) return false;
  
  const rowDiff = toRow - fromRow;
  const colDiff = toCol - fromCol;
  const absRowDiff = Math.abs(rowDiff);
  const absColDiff = Math.abs(colDiff);

  switch (piece.toLowerCase()) {
    case 'p': // Pawn attacks diagonally
      const direction = isWhitePiece(piece) ? -1 : 1;
      return absColDiff === 1 && rowDiff === direction;
    case 'r': // Rook
      return (rowDiff === 0 || colDiff === 0) && isPathClear(fromRow, fromCol, toRow, toCol);
    case 'n': // Knight
      return (absRowDiff === 2 && absColDiff === 1) || (absRowDiff === 1 && absColDiff === 2);
    case 'b': // Bishop
      return absRowDiff === absColDiff && isPathClear(fromRow, fromCol, toRow, toCol);
    case 'q': // Queen
      return (rowDiff === 0 || colDiff === 0 || absRowDiff === absColDiff) && isPathClear(fromRow, fromCol, toRow, toCol);
    case 'k': // King
      return absRowDiff <= 1 && absColDiff <= 1;
    default:
      return false;
  }
}

// Check if king is in check
function isKingInCheck(isWhite) {
  const kingPos = findKing(isWhite);
  if (!kingPos) return false;
  return isSquareUnderAttack(kingPos.row, kingPos.col, !isWhite);
}

// Check if a move would put own king in check
function wouldBeInCheck(fromRow, fromCol, toRow, toCol, isWhite) {
  // Simulate the move
  const originalTarget = board[toRow][toCol];
  const movingPiece = board[fromRow][fromCol];
  
  board[toRow][toCol] = movingPiece;
  board[fromRow][fromCol] = '';
  
  // Check if king would be in check after this move
  const inCheck = isKingInCheck(isWhite);
  
  // Restore the board
  board[fromRow][fromCol] = movingPiece;
  board[toRow][toCol] = originalTarget;
  
  return inCheck;
}

// Get all legal moves (excluding those that would put king in check)
function getPossibleMoves(fromRow, fromCol) {
  const moves = [];
  const piece = board[fromRow][fromCol];
  if (!piece) return moves;

  const isWhite = isWhitePiece(piece);

  for (let toRow = 0; toRow < 8; toRow++) {
    for (let toCol = 0; toCol < 8; toCol++) {
      if (isValidMove(fromRow, fromCol, toRow, toCol)) {
        moves.push({row: toRow, col: toCol});
      }
    }
  }
  return moves;
}

// Check if there are any legal moves for a player
function hasLegalMoves(isWhite) {
  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      const piece = board[row][col];
      if (piece && isWhitePiece(piece) === isWhite) {
        for (let toRow = 0; toRow < 8; toRow++) {
          for (let toCol = 0; toCol < 8; toCol++) {
            if (isValidMove(row, col, toRow, toCol)) {
              return true;
            }
          }
        }
      }
    }
  }
  return false;
}

// Validate chess moves according to all rules
function isValidMove(fromRow, fromCol, toRow, toCol) {
  const piece = board[fromRow][fromCol];
  const targetPiece = board[toRow][toCol];
  
  if (!piece || gameOver) return false;
  if (fromRow === toRow && fromCol === toCol) return false;
  
  // Can't capture your own pieces
  if (targetPiece && isWhitePiece(piece) === isWhitePiece(targetPiece)) {
    return false;
  }
  
  // Check if it's the right player's turn
  const isPieceWhite = isWhitePiece(piece);
  if ((currentPlayer === 'white' && !isPieceWhite) || 
      (currentPlayer === 'black' && isPieceWhite)) {
    return false;
  }

  // Check piece-specific movement rules
  if (!canPieceMove(fromRow, fromCol, toRow, toCol)) {
    return false;
  }
  
  // Check if this move would put own king in check
  if (wouldBeInCheck(fromRow, fromCol, toRow, toCol, isPieceWhite)) {
    return false;
  }

  return true;
}

// Check basic piece movement rules
function canPieceMove(fromRow, fromCol, toRow, toCol) {
  const piece = board[fromRow][fromCol];
  const targetPiece = board[toRow][toCol];
  const rowDiff = toRow - fromRow;
  const colDiff = toCol - fromCol;
  const absRowDiff = Math.abs(rowDiff);
  const absColDiff = Math.abs(colDiff);

  switch (piece.toLowerCase()) {
    case 'p': // Pawn
      const direction = isWhitePiece(piece) ? -1 : 1;
      const startRow = isWhitePiece(piece) ? 6 : 1;
      
      // Forward movement
      if (colDiff === 0 && !targetPiece) {
        if (rowDiff === direction) return true;
        if (fromRow === startRow && rowDiff === 2 * direction) return true;
      }
      // Diagonal capture
      if (absColDiff === 1 && rowDiff === direction && targetPiece) {
        return true;
      }
      return false;

    case 'r': // Rook
      if (rowDiff === 0 || colDiff === 0) {
        return isPathClear(fromRow, fromCol, toRow, toCol);
      }
      return false;

    case 'n': // Knight
      return (absRowDiff === 2 && absColDiff === 1) || (absRowDiff === 1 && absColDiff === 2);

    case 'b': // Bishop
      if (absRowDiff === absColDiff) {
        return isPathClear(fromRow, fromCol, toRow, toCol);
      }
      return false;

    case 'q': // Queen
      if (rowDiff === 0 || colDiff === 0 || absRowDiff === absColDiff) {
        return isPathClear(fromRow, fromCol, toRow, toCol);
      }
      return false;

    case 'k': // King
      return absRowDiff <= 1 && absColDiff <= 1;

    default:
      return false;
  }
}

// Check if path is clear for sliding pieces
function isPathClear(fromRow, fromCol, toRow, toCol) {
  const rowStep = Math.sign(toRow - fromRow);
  const colStep = Math.sign(toCol - fromCol);
  
  let currentRow = fromRow + rowStep;
  let currentCol = fromCol + colStep;
  
  while (currentRow !== toRow || currentCol !== toCol) {
    if (board[currentRow][currentCol] !== '') {
      return false;
    }
    currentRow += rowStep;
    currentCol += colStep;
  }
  
  return true;
}

// Render the chess board with all visual effects
function renderBoard() {
  boardElement.innerHTML = '';
  
  // Update check status
  isWhiteInCheck = isKingInCheck(true);
  isBlackInCheck = isKingInCheck(false);
  
  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      const square = document.createElement('div');
      square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
      square.dataset.row = row;
      square.dataset.col = col;
      
      const piece = board[row][col];
      if (piece) {
        // Create piece symbol
        const pieceSymbol = document.createElement('div');
        pieceSymbol.className = 'piece-symbol';
        pieceSymbol.textContent = pieces[piece];
        
        // Create owner label
        const ownerLabel = document.createElement('div');
        ownerLabel.className = 'piece-owner';
        if (isWhitePiece(piece)) {
          ownerLabel.textContent = 'PLAYER';
          ownerLabel.classList.add('player-piece');
        } else {
          ownerLabel.textContent = 'DOBBY';
          ownerLabel.classList.add('dobby-piece');
        }
        
        square.appendChild(pieceSymbol);
        square.appendChild(ownerLabel);
        
        // Highlight king in check
        if (piece.toLowerCase() === 'k') {
          if ((isWhitePiece(piece) && isWhiteInCheck) || (!isWhitePiece(piece) && isBlackInCheck)) {
            square.classList.add('check-warning');
          }
        }
      }
      
      square.addEventListener('click', () => handleSquareClick(row, col));
      boardElement.appendChild(square);
    }
  }
  
  // Update status based on check/checkmate
  updateGameStatus();
}

// Update game status display
function updateGameStatus() {
  statusElement.className = ''; // Reset classes
  
  if (gameOver) return;
  
  if (currentPlayer === 'white') {
    if (isWhiteInCheck) {
      if (!hasLegalMoves(true)) {
        // Checkmate
        statusElement.textContent = "üíÄ CHECKMATE! Dobby wins!";
        statusElement.className = 'status-checkmate';
        gameOver = true;
        addComment('system', 'üíÄ CHECKMATE! You have no legal moves. Dobby wins!');
        showGameOverMessage(false, 'CHECKMATE! Dobby captured your strategy!');
      } else {
        // Check
        statusElement.textContent = "‚ö†Ô∏è CHECK! Your King is under attack - you must move!";
        statusElement.className = 'status-check';
        addComment('system', '‚ö†Ô∏è CHECK! Your King is under attack!');
      }
    } else {
      if (!hasLegalMoves(true)) {
        // Stalemate
        statusElement.textContent = "ü§ù STALEMATE! It's a draw!";
        gameOver = true;
        addComment('system', 'ü§ù STALEMATE! No legal moves but King is not in check. Draw!');
      } else {
        statusElement.textContent = "Your turn (White) - Click a piece to move";
      }
    }
  } else {
    if (isBlackInCheck) {
      if (!hasLegalMoves(false)) {
        // Checkmate
        statusElement.textContent = "üèÜ CHECKMATE! You win!";
        statusElement.className = 'status-checkmate';
        gameOver = true;
        addComment('system', 'üèÜ CHECKMATE! Dobby has no legal moves. You win!');
        showGameOverMessage(true, 'CHECKMATE! You defeated Dobby!');
      } else {
        // Check
        statusElement.textContent = "Dobby's King is in CHECK! He must respond...";
        statusElement.className = 'status-check';
        addComment('system', '‚ö†Ô∏è Dobby\'s King is in CHECK!');
      }
    } else {
      statusElement.textContent = "Dobby is thinking, check for moves mate...";
    }
  }
}

// Show game over message
function showGameOverMessage(victory, message) {
  setTimeout(() => {
    const overlay = document.createElement('div');
    overlay.className = 'game-over-overlay';
    
    const messageDiv = document.createElement('div');
    messageDiv.className = `game-over-message ${victory ? 'victory' : 'defeat'}`;
    messageDiv.innerHTML = `
      <h2>${victory ? 'üèÜ VICTORY!' : 'üíÄ DEFEAT!'}</h2>
      <p>${message}</p>
      <p><strong>Final Score:</strong></p>
      <p>You: ${whiteScore} points | Dobby: ${blackScore} points</p>
      <button onclick="location.reload()" style="
        background: ${victory ? '#4a9eff' : '#ff4a4a'}; 
        color: white; 
        border: none; 
        padding: 10px 20px; 
        border-radius: 5px; 
        font-size: 16px; 
        cursor: pointer;
        margin-top: 15px;
      ">Play Again</button>
    `;
    
    overlay.appendChild(messageDiv);
    document.body.appendChild(overlay);
  }, 1500);
}

// Handle square clicks
function handleSquareClick(row, col) {
  if (isAnimating || currentPlayer !== 'white' || gameOver) return;

  const piece = board[row][col];

  if (!selectedSquare) {
    // Select a piece
    if (piece && isWhitePiece(piece)) {
      const moves = getPossibleMoves(row, col);
      if (moves.length === 0) {
        addComment('system', 'That piece has no legal moves!');
        return;
      }
      selectedSquare = {row, col};
      possibleMoves = moves;
      highlightSquares();
      statusElement.textContent = `Selected ${pieces[piece]}. Click destination (${moves.length} moves available)`;
    }
  } else {
    // Try to move or select different piece
    if (piece && isWhitePiece(piece)) {
      // Select different piece
      const moves = getPossibleMoves(row, col);
      if (moves.length === 0) {
        addComment('system', 'That piece has no legal moves!');
        return;
      }
      selectedSquare = {row, col};
      possibleMoves = moves;
      highlightSquares();
      statusElement.textContent = `Selected ${pieces[piece]}. Click destination (${moves.length} moves available)`;
    } else if (isValidMove(selectedSquare.row, selectedSquare.col, row, col)) {
      // Make the move
      makeMove(selectedSquare.row, selectedSquare.col, row, col);
    } else {
      // Invalid move
      selectedSquare = null;
      possibleMoves = [];
      renderBoard();
      if (isWhiteInCheck) {
        statusElement.textContent = "‚ö†Ô∏è Invalid move! Your King is in CHECK - you must protect him!";
      } else {
        statusElement.textContent = "Invalid move! Select a piece to move.";
      }
      addComment('system', 'Invalid move - that would violate chess rules!');
    }
  }
}

// Highlight selected square and possible moves
function highlightSquares() {
  renderBoard();
  
  if (selectedSquare) {
    const selectedIndex = selectedSquare.row * 8 + selectedSquare.col;
    boardElement.children[selectedIndex].classList.add('highlight');
    
    possibleMoves.forEach(move => {
      const moveIndex = move.row * 8 + move.col;
      boardElement.children[moveIndex].classList.add('possible-move');
    });
  }
}

// Make a move with animation
function makeMove(fromRow, fromCol, toRow, toCol) {
  if (isAnimating) return;
  
  const piece = board[fromRow][fromCol];
  const capturedPiece = board[toRow][toCol];
  
  // Update king positions
  if (piece.toLowerCase() === 'k') {
    if (isWhitePiece(piece)) {
      whiteKingPos = {row: toRow, col: toCol};
    } else {
      blackKingPos = {row: toRow, col: toCol};
    }
  }
  
  // Record move
  const moveNotation = `${pieces[piece]} ${String.fromCharCode(97 + fromCol)}${8 - fromRow} ‚Üí ${String.fromCharCode(97 + toCol)}${8 - toRow}`;
  
  if (capturedPiece) {
    const points = pieceValues[capturedPiece];
    if (currentPlayer === 'white') {
      whiteScore += points;
      whiteScoreElement.textContent = whiteScore;
      addComment('user', `Captured ${pieces[capturedPiece]}! (+${points} points) - ${moveNotation}`);
    } else {
      blackScore += points;
      blackScoreElement.textContent = blackScore;
      addComment('dobby', `I captured your ${pieces[capturedPiece]}! (+${points} points) - ${moveNotation}`);
    }
  } else {
    if (currentPlayer === 'white') {
      addComment('user', `Moved: ${moveNotation}`);
    }
  }

  animateMove(fromRow, fromCol, toRow, toCol, () => {
    board[toRow][toCol] = piece;
    board[fromRow][fromCol] = '';
    
    selectedSquare = null;
    possibleMoves = [];
    
    // Switch turns
    currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
    
    renderBoard();
    
    if (!gameOver && currentPlayer === 'black') {
      setTimeout(dobbyMove, 1200);
    }
  });
}

// Animate piece movement
function animateMove(fromRow, fromCol, toRow, toCol, callback) {
  isAnimating = true;
  boardElement.classList.add('disabled');
  
  const piece = board[fromRow][fromCol];
  const animatedPiece = document.createElement('div');
  animatedPiece.className = 'animated-piece';
  
  // Create piece symbol for animation
  const pieceSymbol = document.createElement('div');
  pieceSymbol.className = 'piece-symbol';
  pieceSymbol.textContent = pieces[piece];
  
  // Create owner label for animation
  const ownerLabel = document.createElement('div');
  ownerLabel.className = 'piece-owner';
  if (isWhitePiece(piece)) {
    ownerLabel.textContent = 'PLAYER';
    ownerLabel.classList.add('player-piece');
  } else {
    ownerLabel.textContent = 'DOBBY';
    ownerLabel.classList.add('dobby-piece');
  }
  
  animatedPiece.appendChild(pieceSymbol);
  animatedPiece.appendChild(ownerLabel);
  
  // Position at source
  animatedPiece.style.left = (fromCol * 70) + 'px';
  animatedPiece.style.top = (fromRow * 70) + 'px';
  
  boardElement.appendChild(animatedPiece);
  
  // Clear source square visually
  const sourceSquare = boardElement.children[fromRow * 8 + fromCol];
  sourceSquare.innerHTML = '';
  
  // Start animation
  setTimeout(() => {
    animatedPiece.style.left = (toCol * 70) + 'px';
    animatedPiece.style.top = (toRow * 70) + 'px';
  }, 50);
  
  // Complete move
  setTimeout(() => {
    boardElement.removeChild(animatedPiece);
    boardElement.classList.remove('disabled');
    isAnimating = false;
    callback();
  }, 650);
}

// Dobby makes his move
function dobbyMove() {
  if (gameOver) return;
  
  const moves = [];
  
  // Find all valid moves for black pieces
  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      const piece = board[row][col];
      if (piece && !isWhitePiece(piece)) {
        for (let toRow = 0; toRow < 8; toRow++) {
          for (let toCol = 0; toCol < 8; toCol++) {
            if (isValidMove(row, col, toRow, toCol)) {
              const capturedPiece = board[toRow][toCol];
              let priority = 0;
              
              // Prioritize getting out of check
              if (isBlackInCheck) {
                priority += 100;
              }
              
              // Prioritize captures
              if (capturedPiece) {
                priority += pieceValues[capturedPiece] * 10;
              }
              
              // Prioritize moves that put opponent in check
              board[toRow][toCol] = piece;
              board[row][col] = '';
              if (isKingInCheck(true)) {
                priority += 50;
              }
              board[row][col] = piece;
              board[toRow][toCol] = capturedPiece;
              
              // Add some randomness
              priority += Math.random() * 5;
              
              moves.push({
                from: {row, col},
                to: {row: toRow, col: toCol},
                priority: priority
              });
            }
          }
        }
      }
    }
  }

  if (moves.length === 0) {
    // No legal moves - game should already be over due to checkmate/stalemate
    return;
  }

  // Choose the best move
  moves.sort((a, b) => b.priority - a.priority);
  const bestMoves = moves.filter(move => Math.abs(move.priority - moves[0].priority) < 1);
  const chosenMove = bestMoves[Math.floor(Math.random() * bestMoves.length)];

  makeMove(chosenMove.from.row, chosenMove.from.col, chosenMove.to.row, chosenMove.to.col);
  
  // Dobby comment after move (if game isn't over)
  if (!gameOver) {
    setTimeout(dobbyComment, 800);
  }
}

// Add comment to the chat
function addComment(type, message) {
  const comment = document.createElement('div');
  comment.className = `comment ${type}-comment`;
  
  const timestamp = new Date().toLocaleTimeString();
  let prefix = '';
  
  switch(type) {
    case 'user':
      prefix = '<strong>[You]:</strong>';
      break;
    case 'dobby':
      prefix = '<strong>[Dobby]:</strong>';
      break;
    case 'system':
      prefix = '<strong>[System]:</strong>';
      break;
  }
  
  comment.innerHTML = `${prefix} ${message} <small>(${timestamp})</small>`;
  commentsElement.appendChild(comment);
  commentsElement.scrollTop = commentsElement.scrollHeight;
}

// Dobby makes sarcastic comments
async function dobbyComment() {
  try {
    const gameState = `Current score - You: ${whiteScore}, Dobby: ${blackScore}`;
    let context = `Make a sarcastic comment about your chess move. Game state: ${gameState}`;
    
    if (isWhiteInCheck) {
      context += '. You just put the player in CHECK!';
    } else if (isBlackInCheck) {
      context += '. Your King is in check but you escaped!';
    }
    
    const response = await fetch('https://api.fireworks.ai/inference/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${FIREWORKS_API_KEY}`
      },
      body: JSON.stringify({
        model: 'accounts/sentientfoundation-serverless/models/dobby-mini-unhinged-plus-llama-3-1-8b',
        messages: [
          {
            role: 'system',
            content: 'You are Dobby the house-elf, a sarcastic and witty chess opponent. Make brief, sassy comments about chess moves. Stay in character as the magical house-elf from Harry Potter but be playfully competitive and sometimes use mild profanity. Keep responses under 50 words.'
          },
          {
            role: 'user',
            content: context
          }
        ],
        max_tokens: 80,
        temperature: 0.9
      })
    });
    
    const data = await response.json();
    const comment = data.choices?.[0]?.message?.content || "Dobby plays... adequately for a maximum hit!";
    addComment('dobby', comment.trim());
    
  } catch (error) {
    console.error('Dobby comment error:', error);
    const fallbackComments = [
      "Hmph! Dobby's move is superior to yours!",
      "*snaps fingers* Another brilliant move by Dobby!",
      "Master will not win this time!",
      "Dobby is a free elf... and a better chess player!",
      "Your move was... adequate. Unlike Dobby's!",
      "*clicks tongue* Dobby expected better from you!",
      "Dobby's magic is stronger than your strategy!",
      "Even house-elves play better chess than wizards!"
    ];
    
    if (isWhiteInCheck) {
      fallbackComments.push("CHECK! Dobby's got your King cornered!", "Your King trembles before Dobby's power!");
    }
    
    const randomComment = fallbackComments[Math.floor(Math.random() * fallbackComments.length)];
    addComment('dobby', randomComment);
  }
}

// Start the game
initGame();
</script>
     <h1> Made by <a href="https://x.com/agwuchikwendu">WisdomTech</a></h1>
</body>
</html>
